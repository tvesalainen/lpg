/*
 * Copyright (C) 2012 Timo Vesalainen
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.vesalainen.regex.ant;

import java.io.File;
import java.io.IOException;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Task;
import org.vesalainen.bcc.SubClass;
import org.vesalainen.bcc.type.ClassWrapper;
import org.vesalainen.bcc.type.MethodWrapper;
import org.vesalainen.grammar.state.DFA;
import org.vesalainen.parser.util.InputReader;
import org.vesalainen.regex.MatchCompiler;

/**
 * @author Timo Vesalainen
 * @deprecated Use GenClassBuilder!
 */
public class MapTask extends Task 
{
    private AbstractDFAMap<?> map;
    private File destdir;
    private File srcdir;

    public void setMap(String mapClassname)
    {
        try
        {
            Class<?> cls = Class.forName(mapClassname);
            map = (AbstractDFAMap<?>) cls.newInstance();
        }
        catch (InstantiationException | IllegalAccessException | ClassNotFoundException ex)
        {
            throw new BuildException("setting map="+mapClassname+" fails", ex, getLocation());
        }
    }
    public void setDestdir(File destdir)
    {
        this.destdir = destdir;
        log(destdir.getPath());
        log("using " + destdir.getPath() + " for generated byte code");
    }

    public void setSrcdir(File srcdir)
    {
        this.srcdir = srcdir;
        log("using " + srcdir.getPath() + " for generated source");
    }

    @Override
    public void execute() throws BuildException
    {
        try
        {
            Class<? extends MapParser> superClass = map.getParserClass();
            ClassWrapper thisClass = ClassWrapper.wrap(superClass.getName() + "Impl", superClass);
            if (needsCompiling(superClass, thisClass))
            {
                SubClass subClass = new SubClass(thisClass);
                subClass.codeDefaultConstructor();
                log("constructing DFA");
                DFA dfa = map.createDFA();
                MethodWrapper mw = MethodWrapper.wrap(MapParser.class.getDeclaredMethod("input", InputReader.class));
                MatchCompiler<?> ic = new MatchCompiler<>(dfa, map.getErrorToken(), map.getEofToken());
                mw.setImplementor(ic);
                log("implementing " + thisClass);
                subClass.implement(mw);
                log("saving " + thisClass + " to " + destdir);
                subClass.save(destdir);
            }
            else
            {
                log(thisClass.getName()+" is uptodate");
            }
        }
        catch (NoSuchMethodException | SecurityException | IOException ex)
        {
            ex.printStackTrace();
            throw new BuildException("compiling fails", ex, getLocation());
        }
    }
    private boolean needsCompiling(Class<?> superClass, ClassWrapper dstClass)
    {
        String superClassname = superClass.getName().replace('.', '/')+".class";
        String dstClassname = dstClass.getName().replace('.', '/')+".class";
        File superFile = new File(destdir, superClassname);
        File dstFile = new File(destdir, dstClassname);
        return !superFile.exists() || !dstFile.exists() || dstFile.lastModified() < superFile.lastModified();
    }
}
